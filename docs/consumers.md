# Compiler Consumers

This page documents how information needed by verifiers can be currently
extracted from the compiler.

## Calling Compiler

It seems that currently the best way of extracting information from the
compiler is to define a custom driver as illustrated by
[stupid-stats](https://github.com/nrc/stupid-stats) and
[mir-dump](https://github.com/vakaras/mir-dump/) examples. The problem
with this approach is that it does not support incremental recomputation
which would be needed for proper integration into IDE.

## Inline Specifications

It seems that the best way of defining inline specifications is to use
Rust attributes that contain Rust-like code:

```rust
#[ensures="result == a || result == b"]
#[ensures="result >= a && result >= b"]
fn max(a: u32, b: u32) -> u32 {
    if a > b {
        a
    } else {
        b
    }
}
```

Currently, there is no way of type-checking custom Rust code in a
specific context. A possible work-around is to generate dummy Rust code
that corresponds to specifications. For example, one could type-check
the specifications of the function `max` by generating the following
function:
```rust
fn max__spec(a: u32, b: u32) -> u32 {
    let result = max(a, b);
    __assert(1, result == a || result == b);    // “1” here is a unique identifier of the assertion.
    __assert(2, result >= a && result >= b);
    result
}
```

Such dummy code can be generated by using procedural macros or by
transforming the `krate` in
[after_parse](https://github.com/vakaras/mir-dump/blob/892434c45311355e90a683f6df86d0984e16571a/src/driver.rs#L112)
callback. The advantage of the procedural macros approach is that their
API is almost stable. However, with procedural macros it is possible to
transform only annotations on
[items](https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ItemKind.html),
which means that one could not transform loop invariants. Therefore,
either one has to use macro syntax `invariant!(i >= 0)` for defining
loop invariants, or use the `krate` rewriting approach.

Ideally the compiler would provide a query that allows type-checking an
AST fragment in a specific context.

## MIR, MIR analyses, Type Information

MIR of each function can be accessed by traversing the crate with a HIR
visitor and calling either `mir_validated` or `optimised_mir` on `tcx`
as shown
[here](https://github.com/vakaras/mir-dump/blob/892434c45311355e90a683f6df86d0984e16571a/src/mir_dumper.rs#L76).
The current API seems to be sufficient for uses that only require to
access MIR and types. However, accessing results of MIR analyses is
not well-supported. For example:

1.  Results of the definitely initialised analysis are not accessible at
    all (I mention this just as an example – since analysis is very
    simple, this is not a problem in practice).
2.  Extracting the borrow checker information requires a hacky
    work-around as described
    [here](https://github.com/rust-lang-nursery/wg-verification/issues/13).
3.  The borrow information is available only on `mir_validated` while
    drop information is available only in `optimised_mir`. This is
    likely to be a problem if we wanted to verify memory safety of
    unsafe code.

## Open Questions

### Traits

Requirements:

+   Get the list of traits implemented by a specific type.
+   Get the trait on whose method a call is performed.

### Multiple Crates

Requirements:

+   Shipping specifications together with crates so that each crate can
    be verified modularly.
