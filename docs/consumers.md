# Compiler Consumers

This page documents how information needed by verifiers can be currently
extracted from the compiler.

## Calling Compiler

It seems that currently the best way of extracting information from the
compiler is to define a custom driver as illustrated by
[stupid-stats](https://github.com/nrc/stupid-stats) and
[mir-dump](https://github.com/vakaras/mir-dump/) examples. The problem
with this approach is that it does not support incremental recomputation
which would be needed for proper integration into IDE.

## Inline Specifications

It seems that the best way of defining inline specifications is to use
Rust attributes that contain Rust-like code:

```rust
#[ensures="result == a || result == b"]
#[ensures="result >= a && result >= b"]
fn max(a: u32, b: u32) -> u32 {
    if a > b {
        a
    } else {
        b
    }
}
```

Currently, there is no way of type and borrow checking custom Rust code
in a specific context. A possible work-around is to generate dummy Rust
code that corresponds to specifications. For example, one could
type-check the specifications of the function `max` by generating the
following function:
```rust
fn max__spec(a: u32, b: u32) -> u32 {
    let result = max(a, b);
    __assert(1, result == a || result == b);    // “1” here is a unique identifier of the assertion.
    __assert(2, result >= a && result >= b);
    result
}
```

Such dummy code can be generated by using procedural macros or by
transforming the `krate` in
[after_parse](https://github.com/vakaras/mir-dump/blob/892434c45311355e90a683f6df86d0984e16571a/src/driver.rs#L112)
callback. The advantage of the procedural macros approach is that their
API is almost stable. However, with procedural macros it is possible to
transform only annotations on
[items](https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ItemKind.html),
which means that one could not transform loop invariants. Therefore,
either one has to use macro syntax `invariant!(i >= 0)` for defining
loop invariants, or use the `krate` rewriting approach.

Ideally the compiler would provide a query that allows type and borrow
checking an AST fragment in a specific context.

## MIR

MIR of each function can be accessed by traversing the crate with a HIR
visitor and calling either `mir_validated` or `optimised_mir` on `tcx`
as shown
[here](https://github.com/vakaras/mir-dump/blob/892434c45311355e90a683f6df86d0984e16571a/src/mir_dumper.rs#L76).
The API of MIR struct is open enough to work with. For example, the
definition id of a called method can be obtained as shown
[here](https://github.com/vakaras/mir-dump/blob/89ba66d52d5bf28672b9b2aeca5899e72cdafabd/src/mir_dumper.rs#L216-L237).
However, there are no public APIs for accessing the information computed
by various MIR analyses. Therefore, the consumers that need this
information either have to reimplement these analyses (for example,
definitely initialised analysis is sufficiently simple to achieve this)
or use hacks to extract their results (an example hack used to extract
the borrow checker information is described below).

## Borrow Checker Information (Polonius)

The borrow checker information that consumers need are:

1.  The Polonius input facts. (The consumers may need to modify them
    before running Polonius, for example, by replacing all moves of
    borrows with reborrows.)
2.  The mapping between reference typed MIR places and region
    identifiers used in Polonius.
3.  `restricts` and `borrow_live_at` Polonius output relations that are
    used to compute may alias information. Also, the `subset` relation
    for computing `restricts` and `borrow_live_at` of borrows that were
    `killed`.

As far as I know, the only way to get Polonius input facts is to
[pass](https://github.com/vakaras/mir-dump/blob/master/src/driver.rs#L181)
`-Znll-facts` flag to the compiler and then
[parse](https://github.com/vakaras/mir-dump/blob/master/src/borrowck/facts.rs)
the emitted CSV files. The most hacky part of this is
[parsing](https://github.com/vakaras/mir-dump/blob/master/src/borrowck/facts.rs#L70)
strings to restore actual IDs used in MIR.

Obtaining the mapping requires
[passing](https://github.com/vakaras/mir-dump/blob/master/src/driver.rs#L184)
the `-Zdump-mir=renumber` flag to the compiler that makes it to dump a
diagnostics file, which can then be
[parsed](https://github.com/vakaras/mir-dump/blob/master/src/borrowck/regions.rs)
to obtain the mapping.

An ideal solution for me would be to have a query (or queries) on
[TyCtxt](https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.TyCtxt.html)
that returns Polonius input facts and a mapping between MIR places and
region IDs. Having such a query would not only simplify verifiers that
need Polonius information, but would also enable showing visualisations
of borrows in the IDE (we already have some code for this).

**Note:** The borrow information is available only on `mir_validated`
while the drop information is available only in `optimised_mir`. This is
likely to be a problem if we wanted to verify memory safety of unsafe
code.

## Type Information

Compiler consumers based on MIR need to be able to resolve the type of a
MIR Place, which can be done by calling the
[ty](https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html#method.ty)
method. For each type, a consumer needs a way of uniquely identifying it
(also across runs) and for composite types to know from what they are
composed.

## Error Reporting

Nice errors can be easily reported by using the compiler's error
reporting infrastructure. For example, an error at a specific location
can be reported by calling
[span_err_with_code](https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.span_err_with_code).

## Open Questions

### Traits

Requirements:

+   Get the list of traits implemented by a specific type.

### Multiple Crates

Requirements:

+   Shipping specifications together with crates so that each crate can
    be verified modularly.
